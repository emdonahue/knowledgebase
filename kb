#!/bin/zsh

#TODO add update language to query (-d -s?ort -u)
#TODO add options to ls to display different columns
#TODO add ls sorting based on note modification time
#TODO handle multiple filetypes that get added with same md5 (rtf and txt).
#TODO add search by md5
#TODO add bib formatter for bibtex output
#TODO make sed case insensitive for substr match
#TODO deal with adding duplicate keywords

set -o errexit
set -o pipefail
if [[ "${TRACE-0}" == "1" ]]; then set -o xtrace; fi

set -o noclobber
set -o extendedglob
unset c #Reserved variable for inline comments
export LC_COLLATE=C

DIRS=(inbox md5 text bib org)
SCRIPT="$0"
E=(-e)

function disambiguate() { # Accepts md5s or filenames based on md5s and presents a formatted select, returning a single md5
    local MD5S=("${(@f)$(</dev/stdin)}")
    local PS3='Type a number to disambiguate: '
    if [[ ! $MD5S ]]; then echo "kb: No files matching query" >&2 && exit 1; fi
    [[ $#MD5S == 1 ]] && echo "$MD5S" && return
    select MD5 in "${(@f)$(printf '%s\n' "$MD5S[@]" | "$SCRIPT" ls -a)}"; do
	[[ $REPLY -le $#MD5S ]] && echo "$MD5S[$REPLY]" && break
    done < /dev/tty
}

function file2md5() { sed -E 's_^(.*/)*([[:alnum:]]+)(\..*)?$_\2_' }
function md52file() { sed -E 's_.*_'"$1"'/&'"${2:+.$2}"'_' }
function escapepattern() { sed -E 's/[^^]/[&]/g;s/\^/\\^/g' <<< "$1" }

function query() {
    case "$1" in
	'') cat;;
	-a) "$0" "$@[2,-1]";;
	-o) join -a1 -a2 - <("$0" -q "$@[2,-1]");;
	-q) ls bib | "$0" "$@[2,-1]";;
	*)
	    case "$2" in
		-eq|-ne)
		    md52file bib | xargs grep -Ei ${${2:/-eq/-l}:/-ne/-L} '^'"$1"$'\t''.*'"$(escapepattern "$3")" | file2md5 | "$0" "$@[4,-1]"
		    ;;
		*) echo "kb: malformed query: $@" >&2 && exit 1;;
	    esac 
	    ;;
    esac		
}

CMD="$1"

# Ensure proper directory structure
case "$CMD" in
    -h|--help|help|init);;
    *)
	for f in "${DIRS[@]}"; do
	    [[ -d "$f" ]] || {echo 'kb directory structure not detected. Use "kb init" to create a new directory structure.' >&2; exit 1}
	done
	;;
esac

[[ $# -ne 0 ]] && shift
case "$CMD" in
    --help|-h|help) #[SUBCOMMAND]; Prints help text for SUBCOMMAND. If SUBCOMMAND omitted, prints list of subcommands.
	[[ $# -eq 0 ]] && echo 'kb - Personal KnowledgeBase utility for organizing and searching PDFs, other text-based media, notes, etc.\nUsage: kb SUBCOMMAND [ARGUMENTS...]\n\nSubcommands:'
	sed -nE '/\s*'"$1"'\)\s#/'"${1:+,/^\s*;;\s*$/}"'{s/^[[:space:]]*([-|[:alnum:]]+)\)\s#([^;]*); (.*)/'"${${1-\t}:#$1}"'\1 \2\t\3/p; s/.*(\w+)[-+:]*=\w+ \$\{c#(.*); (.*)\}.*/\t-\1 \2\t\3/p}' "$SCRIPT"
	;;

    bib) #[OPTION...] QUERY; Adds or removes records from the bibliography files identified by QUERY. If addition/deletion options are not supplied, print bibliographic data instead.
	zparseopts -D -E d+:=DELETIONS ${c#KEY[=VALUE]; Deletes all fields matching KEY from the bibliography files matching QUERY. If VALUE is provided, only delete fields both matching KEY and conatining VALUE. Can be supplied multiple times for different KEYS and VALUES.}\
		   m+:=INSERTIONS ${c#KEY=VALUE; Inserts VALUE under KEY in bibliography files matching QUERY. -m is for multiple entry. To overwrite previous entries, use -s. Can be supplied multiple times for different KEYS and VALUES}\
		   s+:=UPDATES ${c#KEY=VALUE; Combines -d and -m to delete all previous values for KEY and set KEY to VALUE.}
	DELETIONS=($DELETIONS ${${UPDATES:#-s}%%=*})
	INSERTIONS=($INSERTIONS ${UPDATES:#-s})
	DELETIONS=(${DELETIONS:+$(echo '/'${(j:|:)${(@f)$(printf '%s\n' ${${DELETIONS:#-d}/=/$'\t'} | sed -E 's/[^^]/[&]/g;s/\^/\\^/g;s/\t\]/\\\\t].*/;s/^/\^/')}}'/d')})
	INSERTIONS=('1 i '${^${INSERTIONS:#-m}/=/$'\t'})	
	"$SCRIPT" md5 "$@" | md52file bib | if [[ $INSERTIONS$DELETIONS ]]; then xargs sed -Ei ${INSERTIONS:+${E:^^INSERTIONS}} ${E:^DELETIONS}; else xargs cat; fi
	;;
    
    import) #; Consumes files in inbox and generates appropriate archival copies, analysis extracts, and metadata containers.
	zparseopts -D -E m+:=INSERTIONS ${c#; Apply bibliography records to imported documents. Same as bib -m.}
	find inbox -type f -print0 | while read -d$'\0' f; do
	    IMPORT_MD5=$(md5sum "$f" | cut -f1 -d' ')
	    mv "$f" "md5/$IMPORT_MD5.$f:e"
	    [[ ! -f "org/$IMPORT_MD5.org" ]] && echo '[[file:../md5/'"$IMPORT_MD5"'.'"$f:e"']['"$f:t:r"']]' > "org/$IMPORT_MD5.org"
	    [[ ! -f "bib/$IMPORT_MD5" ]] && echo 'title\t'"$f:t:r"'\nfilename\t'"$f:t:r" > "bib/$IMPORT_MD5"
	    printf '%s\n' ${${INSERTIONS:#-m}/=/$'\t'} >> "bib/$IMPORT_MD5"
	done
	;;
    
    init) #; Generates a new directory structure for use by kb in the current directory.
	mkdir -p "${DIRS[@]}"
	;;

    ls) #[QUERY]; Lists files matching QUERY. If QUERY omitted, list all files.
	#TODO use sed hold space to clip out title, author, year in desired order
	"$SCRIPT" md5 -rsn "$@" | md52file bib | xargs sed -nE 's/^title'$'\t''(.*)/\1/p'
	;;

    md5) #[QUERY]; Prints md5s of files matching QUERY. If QUERY is omitted, print all md5s.
	zparseopts -D -E i=INTERACTIVE\
		   s:=SORT ${c#ORDER; Sorts elements by timestamp. SORT may be any of: i (time imported), o (time opened), n (time notes opened). Because the -a and -o query flags rely on order, do not sort any but the last in a series of joined queries.}\
		   r=REVERSE ${c#; Reverses sort order}
	declare -A SORTDIR SORTTIMESTAMP
	SORTDIR=([o]=md5 [i]=md5 [n]=org)
	SORTTIMESTAMP=([o]=A [i]=T [n]=T)
	query ${=${${:--q $1}:/-q -a/-a}:/-q -b/-b} "$@[2,-1]" | {[[ $INTERACTIVE ]] && disambiguate || cat} | if [[ $SORT ]]; then join - <(find $SORTDIR[$SORT[2]] -type f -printf '%P %'$SORTTIMESTAMP[$SORT[2]]'@\n' | sed 's/\.[^ ]* / /' | sort -k1,1) | sort $REVERSE -nk2,2 | cut -f1 -d' '; else cat; fi
	;;

    open) #QUERY; Opens the document matching QUERY using xdg-open to select an appropriate application.
	xdg-open md5/$("$SCRIPT" md5 -i "$@").*
	;;
    
    org) #QUERY; Opens the org notes file for the document matching QUERY using $EDITOR.
	${=EDITOR} org/$("$SCRIPT" md5 -rsn -i "$@").org
	;;
    
    *)	
	"$SCRIPT" help >&2
	exit 1
	;;
esac
