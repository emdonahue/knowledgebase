#!/bin/zsh

#TODO handle multiple filetypes that get added with same md5 (rtf and txt)
#TODO handle merging versions of the same bibliographic item (symlink notes and bib?)
#TODO add search by md5
#TODO add dates to query language
#TODO add regex alongside -eq, maybe -re
#TODO add bib formatter for bibtex output
#TODO guarantee keywords already exist when adding if specified
#TODO make bib break if fields dont have "="

set -o errexit
set -o pipefail
if [[ "${TRACE-0}" == "1" ]]; then set -o xtrace; fi

set -o noclobber
set -o extendedglob
unset c #Reserved variable for inline comments
export LC_COLLATE=C

local DIRS=(inbox md5 text bib org)
local SCRIPT="$0"
local E=(-e)

function disambiguate() { # Accepts md5s or filenames based on md5s and presents a formatted select, returning a single md5
    local MD5S=("${(@f)$(</dev/stdin)}")
    local PS3='Type a number to disambiguate: '
    if [[ ! $MD5S ]]; then echo "kb: No files matching query" >&2 && exit 1; fi
    [[ $#MD5S == 1 ]] && echo "$MD5S" && return
    select MD5 in "${(@f)$(printf '%s\n' "$MD5S[@]" | "$SCRIPT" ls "$@" -a)}"; do
	[[ $REPLY -le $#MD5S ]] && echo "$MD5S[$REPLY]" && break
    done < /dev/tty
}

function file2md5() { sed -E 's_^(.*/)*([[:alnum:]]+)(\..*)?$_\2_' }
function md52file() { sed -E 's_.*_'"$1"'/&'"${2:+.$2}"'_' }
function escapepattern() { sed -E 's/[^^]/[\L&\U&]/g;s/\^/\\^/g' <<< "$1" }

function query() {
    case "$1" in
	'') cat;;
	-a) "$0" "$@[2,-1]";;
	-o) join -a1 -a2 - <("$0" -q "$@[2,-1]");;
	-q) ls bib | "$0" "$@[2,-1]";;
	--subq) cat "$2" | "$0" "$@[3,-1]";;
	-eq|-ne)
	    local NEGATION=${${1:/-eq/-l}:/-ne/-L}
	    local PATTERN="$(escapepattern "$3")"
	    case "$2" in
		--org|--note|--notes)
		    md52file org org | xargs grep -Ei "$NEGATION" "$PATTERN";;
		*)
		    md52file bib | xargs grep -Ei "$NEGATION" '^'"${2:/--bib/[^"$'\t'"]+}"$'\t''.*'"$PATTERN";;
	    esac | file2md5 | "$0" "$@[4,-1]";;
	*)
	    if [[ "$2" == -eq || "$2" == -ne ]]; then
		"$0" "$2" "$1" "$@[3,-1]"
	    else
		echo "kb: malformed query: $@" >&2
		exit 1
	    fi
	    ;;
    esac		
}

local CMD="$1"

# Ensure proper directory structure
case "$CMD" in
    -h|--help|help|init);;
    *)
	for f in "${DIRS[@]}"; do
	    [[ -d "$f" && -f .config ]] || {echo 'kb directory structure not detected. Use "kb init" to create a new directory structure.' >&2; exit 1}
	done
	source .config
	;;
esac

[[ $# -ne 0 ]] && shift
case "$CMD" in
    --help|-h|help) #[SUBCOMMAND]; Prints help text for SUBCOMMAND. If SUBCOMMAND omitted, prints list of subcommands.
	[[ $# -eq 0 ]] && echo 'kb - Personal KnowledgeBase utility for organizing and searching PDFs, other text-based media, notes, etc.\nUsage: kb SUBCOMMAND [ARGUMENTS...]\n\nSubcommands:'
	sed -nE '/\s*'"$1"'\)\s#/'"${1:+,/^\s*;;\s*$/}"'{s/^[[:space:]]*([-|[:alnum:]]+)\)\s#([^;]*); (.*)/'"${${1-\t}:#$1}"'\1 \2\t\3/p; s/.*(\w+)[-+:]*=\w+ \$\{c#(.*); (.*)\}.*/\t-\1 \2\t\3/p}' "$SCRIPT"
	;;

    bib) #[OPTION...] QUERY; Adds or removes records from the bibliography files identified by QUERY. If addition/deletion options are not supplied, print bibliographic data instead.
	zparseopts -D -E d+:=DELETIONS ${c#KEY[=VALUE]; Deletes all fields matching KEY from the bibliography files matching QUERY. If VALUE is provided, only delete fields both matching KEY and conatining VALUE. Can be supplied multiple times for different KEYS and VALUES.}\
		   k+:=INSERTIONS ${c#KEY=VALUE; Inserts VALUE under KEY in bibliography files matching QUERY. To overwrite previous entries, use -s. Can be supplied multiple times for different KEYS and VALUES}\
		   s+:=UPDATES ${c#KEY=VALUE; Combines -d and -k to delete all previous values for KEY and set KEY to VALUE.}
	DELETIONS=($DELETIONS ${${UPDATES:#-s}%%=*})
	INSERTIONS=($INSERTIONS ${UPDATES:#-s})
	DELETIONS=(${DELETIONS:+$(echo '/'${(j:|:)${(@f)$(printf '%s\n' ${${DELETIONS:#-d}/=/$'\t'} | sed -E 's/[^^]/[&]/g;s/\^/\\^/g;s/\t\]/\\\\t].*/;s/^/\^/')}}'/d')})
	INSERTIONS=('1 i '${^${INSERTIONS:#-k}/=/$'\t'})	
	"$SCRIPT" md5 "$@" | md52file bib | if [[ $INSERTIONS$DELETIONS ]]; then
	    while read bib; do
		sed -Ei ${INSERTIONS:+${E:^^INSERTIONS}} ${E:^DELETIONS} "$bib"
		sort -uo "$bib" "$bib"
	    done
	else xargs cat
	fi
	;;
    
    import) #; Consumes files in inbox and generates appropriate archival copies, analysis extracts, and metadata containers. Automatically adds both a title and a filename field to the bibliography, both corresponding to the original filename.
	zparseopts -D -F d+:=BIBCMDS ${c#; Delete bibliography keys from imported documents. Same as bib -d.}\
		   k+:=BIBCMDS ${c#; Add bibliography keys to imported documents. Same as bib -k.}\
		   s+:=BIBCMDS ${c#; Set bibliography keys on imported documents. Same as bib -s.}
	find inbox -type f -print0 | while read -d$'\0' f; do
	    local IMPORT_MD5=$(md5sum "$f" | cut -f1 -d' ')
	    mv "$f" "md5/$IMPORT_MD5.$f:e"
	    [[ ! -f "org/$IMPORT_MD5.org" ]] && echo '[[file:../md5/'"$IMPORT_MD5"'.'"$f:e"']['"$f:t:r"']]' > "org/$IMPORT_MD5.org"
	    [[ ! -f "bib/$IMPORT_MD5" ]] && echo 'filename\t'"$f:t:r"'\ntitle\t'"$f:t:r" > "bib/$IMPORT_MD5"
	    if [[ "$BIBCMDS" ]]; then
		"$0" bib "${BIBCMDS[@]}" -a <<< "$IMPORT_MD5"
		sort -uo "bib/$IMPORT_MD5" "bib/$IMPORT_MD5"
	    fi
	done
	;;
    
    init) #; Generates a new directory structure for use by kb in the current directory.
	mkdir -p "${DIRS[@]}"
	if [[ ! -f .config ]]; then
	    echo "LS_COLUMNS=(title) #Default columns printed by ls." > .config
	fi
	;;

    ls) #[QUERY]; Prints a TSV of files matching QUERY. If QUERY omitted, list all files.
	zparseopts -D -E -K c+:=LS_COLUMNS ${c#BIBkEY; Adds a bibliography key as a column in the output. Default is title. Adding new keys with -c will overwrite the defaults, but -c may be called multiple times. Special column name "md5" prints the md5 of the file.}\
		   h=HEADERS ${c#; Prints column headers.}
	"$SCRIPT" md5 "$@" | md52file bib | xargs awk -vFS='\t' -vOFS='\t' -vLS_COLUMNS=${(j:\t:)LS_COLUMNS:#-c} -vHEADERS=$#HEADERS 'BEGIN {if (HEADERS) print LS_COLUMNS; split(LS_COLUMNS,hs,"\t")} {keys[$1]=$2} ENDFILE {keys["md5"]=substr(FILENAME,index(FILENAME,"/")+1); for (i=1;i<=length(hs);i++) printf("%s%s",keys[hs[i]],i==length(hs)?RS:FS); delete keys}'
	;;

    md5) #[QUERY]; Prints md5s of files matching QUERY. If QUERY is omitted, print all md5s.
	zparseopts -D -E i=INTERACTIVE\
		   s:=SORT ${c#ORDER; Sorts elements by timestamp. SORT may be any of: i (time imported), o (time opened), n (time notes opened). Because the -a and -o query flags rely on order, do not sort any but the last in a series of joined queries.}\
		   r=REVERSE ${c#; Reverses sort order}
	declare -A SORTDIR SORTTIMESTAMP
	local SORTDIR=([o]=md5 [i]=md5 [n]=org)
	local SORTTIMESTAMP=([o]=A [i]=T [n]=T)
	query ${=${${:--q $1}:/-q -a/-a}:/-q -b/-b} "$@[2,-1]" | {[[ $INTERACTIVE ]] && disambiguate "$SORT[@]" "$REVERSE[@]" || if [[ $SORT ]]; then join - <(find $SORTDIR[$SORT[2]] -type f -printf '%P %'$SORTTIMESTAMP[$SORT[2]]'@\n' | sed 's/\.[^ ]* / /' | sort -k1,1) | sort $REVERSE -nk2,2 | cut -f1 -d' '; else cat; fi}
	;;

    open) #QUERY; Opens the document matching QUERY using xdg-open to select an appropriate application.
	OPENFILE=$("$SCRIPT" md5 -rso -i "$@")
	[[ $OPENFILE ]] && xdg-open md5/"$OPENFILE".*	
	;;
    
    org) #QUERY; Opens the org notes file for the document matching QUERY using $EDITOR.
	local ORGFILE=$("$SCRIPT" md5 -rsn -i "$@" | md52file org org)
	[[ $ORGFILE ]] && ${=EDITOR} $ORGFILE
	;;
    
    *)	
	"$SCRIPT" help >&2
	exit 1
	;;
esac
